name: run code 

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
    contents: write

jobs:
  job_name:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 
        uses: actions/checkout@v4

      - name: run code
        run: |
          sudo pip install -U tensorflow;
          sudo pip install pillow;
          sudo pip install numpy;
          cat > out.py << EOF
          import os 
          import sys
          from PIL import Image
          import numpy as np
          import requests
          import tensorflow as tf
          # ----------------------
          def fetch_an_image(url, desired_file_name):
            response = requests.get(url)
          
            with open(desired_file_name, 'wb') as file:
                file.write(response.content)
          # ----------------------
          def np_filename_to_3shapeArray(file_name, img_w, img_h):

            # Read image from file
            np_arr_3shape_int = np.array(Image.open(file_name).resize((img_w, img_h)))
            print("np_arr_3shape_int.shape: ", np_arr_3shape_int.shape) # (img_w, img_h, 4)
            
            # Remove alpha layer
            np_arr_3shape_int = np_arr_3shape_int[:, :, 0:3]
            print("np_arr_3shape_int.shape: ", np_arr_3shape_int.shape) # (img_w, img_h, 3)

            # Add batch_size
            np_arr_4shape_int = np.expand_dims(np_arr_3shape_int, axis=0) # (batch_size=1, img_w, img_h, 3) = (1, width, height, RGB)
            
            return np_arr_4shape_int
          # ----------------------
          def np_save_3shapeArray_to_file(np_arr_4shape_float, output_fileName):

            # np_arr_4shape_float : (batch_size=1, img_w, img_h, 3)
            
            # Remove batch_size
            np_arr_3shape_float = np.squeeze(np_arr_4shape_float) 
            print('np_arr_3shape_float.shape: ', np_arr_3shape_float.shape) # (img_w, img_h, 3) 
            
            # Convert to int dtype
            np_arr_3shape_int = np.array(np_arr_3shape_float, dtype=np.uint8)
            
            # Save image to file
            image_out = Image.fromarray(np_arr_3shape_int)
            image_out.save(output_fileName+".png")
          # ----------------------
          def np_normalize_3shapeArray(np_arr_3shape):

            print('np.max(np_arr_3shape): ', np.max(np_arr_3shape))  # 255
            print('np.min(np_arr_3shape): ', np.min(np_arr_3shape))  # 0
          
            # Check if max-min > 1
            if ( np.abs(np.max(np_arr_3shape) - np.min(np_arr_3shape)) > 1):
              # Array_image is not normalized
              np_arr_3shape = np_arr_3shape/255;
              
            return np_arr_3shape
          # ----------------------
          def tf_convert_to_np(tf_arr):
            return tf_arr.numpy();
          # ----------------------
          
          # ----------------------

          # ----------------------
          img_w = 224
          img_h = 224
          # ----------------------
          # [0] Fetch the original image
          # ----------------------
          url = 'https://storage.googleapis.com/neural-style-transfer/original/original2.png'
          desired_file_name = "image_to_receive_a_style.png"
          
          # Saves image to file path
          fetch_an_image(url, desired_file_name)
          
          # Read in image, convert to a 4shape array
          org_arr_np = np_filename_to_3shapeArray(desired_file_name, img_w, img_h)

          # Normalize the image from [-1, 1]
          org_arr_np = np_normalize_3shapeArray(org_arr_np)
          # ----------------------
          # [1] Fetch the style image
          # ----------------------
          url = 'https://storage.googleapis.com/neural-style-transfer/style/style0.png'
          desired_file_name = "image_to_give_a_style.png"
          
          # Saves image to file path
          fetch_an_image(url, desired_file_name)
          
          # Read in image and convert to a 4shape array
          style_arr_np = np_filename_to_3shapeArray(desired_file_name, img_w, img_h)
          
          # Normalize the image from [-1, 1]
          style_arr_np = np_normalize_3shapeArray(style_arr_np)

          # np_save_3shapeArray_to_file(style_arr_np, "style_arr_np")
          # ----------------------
          # [2] Randomly initialize the generated_arr
          # ----------------------
          # tf.Variable is a tensor that does not change type or shape.
          generated_arr_tf = tf.Variable(tf.image.convert_image_dtype(org_arr_np, tf.float32))
          
          noise_tf = tf.random.uniform(tf.shape(generated_arr_tf), -0.25, 0.25)
          
          generated_arr_tf = tf.add(generated_arr_tf, noise_tf) # Add noise to the original image.
          generated_arr_tf = tf.clip_by_value(generated_arr_tf, clip_value_min=0.0, clip_value_max=1.0)
          
          print('generated_arr_tf.shape: ', generated_arr_tf.shape)    # (1, img_w, img_h, 3)

          generated_arr_np = tf_convert_to_np(generated_arr_tf)
          
          np_save_3shapeArray_to_file(generated_arr_np, "generated_arr_np")
          # ----------------------
          # [3] Load the pre-trained VGG19 model
          # ----------------------
          # include_top=False means do not include the layers close to the output.
          # Inputs should be from [0, 255].
          vgg = tf.keras.applications.VGG19(include_top=False,
                                            input_shape=(img_w, img_h, 3),
                                            weights='imagenet',
                                            classes=1000,
                                            classifier_activation='softmax')
          vgg.trainable = False
          # ----------------------
          # [4] Create two models from the VGG19 model layers
          # ----------------------
          inputs = [vgg.input]

          # Original model
          SELECTED_ORG_LAYERS = [('block5_conv4', 1)]
          outputs_org = [vgg.get_layer(layer[0]).output for layer in SELECTED_ORG_LAYERS] # acts like a filter
          model_org = tf.keras.Model(inputs, outputs_org) 
          
          # Style model
          SELECTED_STYLE_LAYERS = [('block1_conv1', 0.2), ('block2_conv1', 0.2), ('block3_conv1', 0.2), ('block4_conv1', 0.2), ('block5_conv1', 0.2)]
          outputs_style = [vgg.get_layer(layer[0]).output for layer in SELECTED_STYLE_LAYERS] # acts like a filter
          model_style = tf.keras.Model(inputs, outputs_style)
          # ----------------------
          # [5] Define the cost function for training
          # ----------------------
          optimizer = tf.keras.optimizers.Adam(learning_rate=0.01)
          # ----------------------
          # [6] Compute the Original image Encoding (a_O)
          # ----------------------
          org_arr_tf_float =  tf.Variable(tf.image.convert_image_dtype(org_arr_np, tf.float32))
          a_O = model_org(org_arr_tf_float)
          # ----------------------
          # [7] Compute the Style image Encoding (a_S)
          # ----------------------
          style_arr_tf_float =  tf.Variable(tf.image.convert_image_dtype(style_arr_np, tf.float32))
          a_S = model_style(style_arr_tf_float)
          # ----------------------
          EOF
          python out.py;

      - name: Save output files to repo
        run: |
          repoOwner=$(echo "${{ github.repository }}" | cut -d '/' -f 1);
          repoOwnerEmail="j622amilah@gmail.com";
          repoName=$(echo "${{ github.repository }}" | cut -d '/' -f 2);
          git config --global user.email ${repoOwnerEmail};
          git config --global user.name ${repoOwner};
          git remote set-url origin https://git:${GITHUB_TOKEN}@github.com/${repoOwner}/${repoName}.git
          git reset  
          git add /home/runner/work/${repoName}/${repoName}/initial_generated_arr.png
          git commit -m "add output files to repo"
          git push
          
          
