var arr = [
[0,  7,  9,  0, 0, 14], 
[7,  0, 10, 15, 0, 0], 
[9, 10,  0, 11, 0, 2], 
[0, 15, 11,  0, 6, 0], 
[0,  0,  0,  6, 0, 9], 
[14, 0,  2,  0, 9, 0]];



// -------------------------------


// Inside a webapp function
var start_distances = arr.at(0).filter((x) => x != 0);
var end_distances = arr.at(arr.length-1).filter((x) => x != 0);

var total_paths = [];

for (var i=0; i<start_distances.length; i++) {

  var second_val_row = 0; // this value is used to create the height and width for the new smaller array around the value such that it is on the diagonal (to find a matching diagonal value).
  var last_nonzero_row_val = start_distances.at(i);
  var path = [];
  
  [second_val_row, last_nonzero_row_val, path] = find_edge_distance(second_val_row, last_nonzero_row_val, path);
  console.log("path: ", path);

  total_paths.push(path);
}

console.log("total_paths: ", total_paths);






function find_edge_distance(second_val_row, last_nonzero_row_val, path) {


// --------------------
// Save the current distance
// --------------------
path.push(last_nonzero_row_val);



// --------------------
//  Check for the next distance
// --------------------
// Remove unneeded top rows and last row.
var arr_start_rows = arr.slice(second_val_row, arr.length-2);

// [0] Obtain a part of the original array, with respect to val.

// Specify number of columns in the array part.
// Obtain the first row with columns up to last_nonzero_row_val.
var colnums = arr.at(0).length;
var arr_part_first_row = [];
var fl = false;
for (var i=0; i<colnums; i++) {
  if (fl == false){
    arr_part_first_row.push(arr_start_rows.at(0).at(i));
    if (arr_start_rows.at(0).at(i) == last_nonzero_row_val) {fl = true;}
  }
}
// console.log("arr_part_first_row: ", arr_part_first_row);
var arr_part_colnum = arr_part_first_row.length;

// Make a square array where last_nonzero_row_val is at the [top right corner] of the array.
var arr_part = arr_start_rows.map((row, row_count) => { 
  if (row_count < arr_part_colnum) {
    return row.slice(0,arr_part_colnum);
  } else {
    return "";
  }
}).filter((x) => x != "");
// console.log("arr_part: ", arr_part);

// arr_part does not have to be a square array.
// The zeros padded below to make the rows the same length as the columns are assumed, but do not need to be calculated because the diagonal element calculation does not need a square array.


// [1] Find the second repeating val on the left upper diagonal of the arr_part.

// Calculate the left upper diagonal of the array
var left_upper_diag = arr_part.map((row, i) => { return row.at(arr_part.at(0).length - i - 1); });
// console.log("left_upper_diag: ", left_upper_diag);

// Calculate the row that [last_nonzero_row_val appears on the diagonal a 2nd time]
var index = left_upper_diag.map((x, ind) => { return (x == last_nonzero_row_val) ? ind : ""; }).filter((x) => x != "");
// console.log("index: ", index);
second_val_row = Math.max(index);
// console.log("second_val_row: ", second_val_row);


// [2] Find the last non-zero row value in the arr, where row=second_val_row.
var x_prev = arr.at(second_val_row).at(0);
var vals_before_zero = arr.at(second_val_row).map((x, i) => { 
  if (x == 0) {
    var out = x_prev;
  } else {
    var out = "";
  }
  x_prev = x;
  return out;
}).filter((x) => x != "");
// console.log("vals_before_zero: ", vals_before_zero);

// last non-zero row value
var last_nonzero_row_val = vals_before_zero.pop();
// console.log("last_nonzero_row_val: ", last_nonzero_row_val);


// --------------------
// Deterimine if a next distance exists.
// --------------------
// last column check
var val_col_index = arr.at(second_val_row).findIndex((x) => x == last_nonzero_row_val);
if (val_col_index < colnums-1) {
   [second_val_row, last_nonzero_row_val, path] = find_edge_distance(second_val_row, last_nonzero_row_val, path);
}


return [second_val_row, last_nonzero_row_val, path];
}
javascript