<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="run_selection" onclick="run_selection()">Run Selection</button>

<div id="output">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>


async function run_selection() {

  const epochs = 200;
  const batchSize = 32;
  const lr = 0.01;


  // Create xs and ys arrays.
  const rows = 100;
  const cols = 10;
  var [xs, ys] = await create_xs_ys(rows, cols);
  

  // Create a dataset, shuffle and batch 32 samples at a time.
  const bufferSize = 100;
  const ds = tf.data.zip({xs, ys}).shuffle(bufferSize).batch(batchSize);
  

  // Create the model
  const input = tf.input({shape: [cols]});
  const dense0 = tf.layers.dense({units: 32, activation: 'relu'});
  const dense1 = tf.layers.dense({units: 2, activation: 'softmax'});
  const output = dense1.apply(dense0.apply(input));
  const model = tf.model({inputs: input, outputs: output});
  document.getElementById("output").innerHTML += "model: "+model+"<br>";


  // Define a method to compute the updated [weights and biases].
  const optimizer = tf.train.sgd(lr);
  // OR
  // const optimizer = 'sgd';
  

  // Create a "numerical template" of the neural network model, called a graph.
  model.compile({
    optimizer: optimizer,
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy']
  });


// Train the model.
const history = await model.fitDataset(ds, {
   epochs: epochs,
   // batchSize: batchSize,
   callbacks: {
     onEpochEnd: async (epoch, logs) => {
       if (epoch%20 == 0) {
         document.getElementById("output").innerHTML += "(epoch/epochs)*100: "+(epoch/epochs)*100+"<br>";
       }
     }
   }
 }); //end of fitDataset
 document.getElementById("output").innerHTML += "history: "+history+"<br>";


 // Predict some new samples.
 const rows_test = 2;
 const cols_test = 10;
 var [xs_test, ys_test] = await create_xs_ys(rows_test, cols_test);
 var ys_test_pred = await predict(model, xs_test);
 document.getElementById("output").innerHTML += "ys_test: "+ys_test+"<br>";
 document.getElementById("output").innerHTML += "ys_test_pred: "+ys_test_pred+"<br>";


} // end of run_selection



async function create_xs_ys(rows, cols) {

  var xs = [];
  var ys = [];
  for (var i=0; i<rows; i++) {
    if (i%2 == 0) {
      var data0 = Array.from({length: cols}, (x) => Math.random());
      xs.push(data0);
      ys.push(0);
    } else {
      var data1 = Array.from({length: cols}, (x) => 10*Math.random());
      xs.push(data1);
      ys.push(1);
    }
  }

  xs = await tf.tensor(xs, [rows, cols]);
  ys = await tf.oneHot(tf.tensor1d(ys, 'int32'), 2);

  // A wrapper function that allows for parallel processing/optimal data fetching.
  // xs = tf.data.generator(xs);
  // ys = tf.data.generator(ys);

  return [xs, ys];
}



function onBatchEnd(batch, logs) {
  document.getElementById("output").innerHTML += "."+batch;
  // document.getElementById("output").innerHTML += "logs.acc: "+logs.acc+"<br>";
}



async function predict(model, xs_test) {
  return model.predict(xs_test);
}


</script>
</body>
</html>
