<!DOCTYPE>
<html>
<head></head>
<body>

<button id="run_selection" onclick="run_selection()">Run Selection</button>


<div id="output">


<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script src="https://cdn.plot.ly/plotly-2.30.0.min.js" charset="utf-8"></script>

<script>

async function run_selection() {

  const n = 200;
  const x_max = 1;

  var x = Array.from({length: n}, (v,i) => { return (x_max/n)* i; });
  document.getElementById("output").innerHTML += "x: "+x.slice(0,10)+"<br>";

  var xs_js = x.map((v,i) => { return [1*Math.sin(v), 2*Math.cos(v), 5*Math.sin(v)]; });
  const rows = xs_js.length;
  const cols = xs_js.at(0).length;
  xs = tf.tensor(xs_js, [rows, cols]);
  document.getElementById("output").innerHTML += "xs: "+xs+"<br>";

  var ys_js = Array.from({length: n}, (v,i) => { return (i < n/2) ? 0 : 1; });
  ys = tf.tensor(ys_js);
  document.getElementById("output").innerHTML += "ys: "+ys+"<br>";

  const batch_size = 1;
  const epochs = 200;

  const model = await lstm_model(batch_size, rows, cols);
  document.getElementById("output").innerHTML += "model: "+model+"<br>";

  model.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ["mse"] })

  const history = await model.fit(xs, ys, {
    batchSize: batch_size,
    epochs: epochs,
    callbacks: {onBatchEnd}
  }).then(result => { 
    document.getElementById("output").innerHTML += "result: "+result+"<br>";
    return result.history;
  });
  document.getElementById("output").innerHTML += "history: "+history+"<br>";

  const xs_js_test = await [xs_js.at(20), xs_js.at(150)];
  const result = await model.predict(tf.tensor(xs_js_test));
  document.getElementById("output").innerHTML += "result: "+result+"<br>";

  const ys_js_test = await [ys_js.at(20), ys_js.at(150)];
  document.getElementById("output").innerHTML += "ys_js_test: "+ys_js_test+"<br>";

}



function onBatchEnd(batch, logs) {
  document.getElementById("output").innerHTML += "logs: "+logs+"<br>";
}


function onEpochEnd(epoch, logs) {
  if (epoch % 100 == 0) {
    document.getElementById("output").innerHTML += "logs: "+logs+"<br>";
  }
}





async function lstm_model(batch_size, rows, cols) {

  // Layer 0
  const input = tf.input({batchShape: [batch_size, rows, cols]});
  document.getElementById("output").innerHTML += "input.shape: "+JSON.stringify(input.shape)+"<br>";

  // Layer 1
  const lstm0 = tf.layers.lstm({
    recurrentActivation: "hardSigmoid",
    units: 32,
    returnSequences: true,
    returnState: false,
    kernelInitializer: "heNormal",
    batchSize: batch_size,
    inputShape: [rows, cols],
    activation: "tanh", 
    trainable: true, 
    dropout: 0.2
})

const input_lstm0 = lstm0.apply(input);
document.getElementById("output").innerHTML += "input_lstm0.shape: "+JSON.stringify(input_lstm0.shape)+"<br>";

// Layer 2
var attSoftmax = tf.layers.activation({activation: "softmax"});
const input_lstm0_softmax = attSoftmax.apply(input_lstm0);
document.getElementById("output").innerHTML += "input_lstm0_softmax.shape: "+JSON.stringify(input_lstm0_softmax.shape)+"<br>";

// Layer 3
const attDot_product = tf.layers.dot({axes: -1});
const input_lstm0_att = attDot_product.apply([input_lstm0_softmax, input_lstm0]);
document.getElementById("output").innerHTML += "input_lstm0_att.shape: "+JSON.stringify(input_lstm0_att.shape)+"<br>";

// Layer 4
const dense0 = tf.layers.dense({units: 1})

const output = dense0.apply(input_lstm0_att);
document.getElementById("output").innerHTML += "output.shape: "+JSON.stringify(output.shape)+"<br>";

const model = tf.model({inputs: input, outputs: output})

return model;
}


</script>
</body>
</html>
