<!DOCTYPE>
<html>
<head></head>
<body>

<button class="button_row" onclick="step0_display_visor()">0. Display Visor</button>
<button class="button_row" onclick="step1_clear_visor()">1. Clear Visor</button>
<button class="button_row" onclick="step2_get_ImageArray()">2. Get canvas ImageData</button>
<button class="button_row" onclick="step3_create_unique_data()">3. Create Data</button>
<button class="button_row" onclick="step4()">4. Change ImageData</button>
<button class="button_row" onclick="step5_change_visor()">5. Change Visor</button>

<button class="button_row" onclick="step6_create_ys_data()">6. Create ys Data</button>
<button class="button_row" onclick="step7_create_xs_data()">7. Create xs Data</button>
<button class="button_row" onclick="step8_load_test_data()">8. Load Test Data</button>

<button class="button_row" onclick="step9_load_model()">9. Load Model</button>
<button class="button_row" onclick="step10_compile_model()">10. Compile Model</button>
<button class="button_row" onclick="step11_train_model()">11. Train Model</button>
<button class="button_row" onclick="step12_predict()">12. Predict</button>

<div id="display_data"></div> 

<div id="output"></div>

<style>
.button_row { 
  background-color: seagreen; 
}

.button_row:focus { 
  background-color: lightpink;
}

.canvas_simple {
  position: relative;
  border: "2px solid black";
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}
</style>


<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js" charset="utf-8"></script>


<script>
var width = 100;
var height = 100;

var canvasElement0;
var ctx0;
var canvasElement1;
var ctx1;

var normalArray0;
var normalArray1;

var x3d_label0 = [];
var x3d_label1 = [];
var IMAGE_WIDTH  = width;  // cols
var IMAGE_HEIGHT = height;  // rows
var IMAGE_CHANNELS = 3;

var TypedArray0;
var TypedArray1;

var n = 10;

const NUM_OUTPUT_CLASSES = 2;
var model;
const batch_size = 1;
const epochs = 10;


// --------------------------
// View unique data labels.
// --------------------------
function step0_display_visor() {
  [ctx0, canvasElement0] = create_canvas("canvasElement_id0");
  [ctx1, canvasElement1] = create_canvas("canvasElement_id1");
}

function step1_clear_visor() {
  reset(canvasElement0);
  reset(canvasElement1)
}

function step2_get_ImageArray() {
  normalArray0 = convert_canvas_into_ImageData(ctx0);
  document.getElementById("output").innerHTML += "normalArray0.length :"+normalArray0.length+"<br>";
  
  normalArray1 = convert_canvas_into_ImageData(ctx1);
  document.getElementById("output").innerHTML += "normalArray1.length :"+normalArray1.length+"<br>";
}


function step3_create_unique_data() {
  
  var x2d_label0 = Array.from({length: IMAGE_HEIGHT}, (v0,i0) => { 
    return Array.from({length: IMAGE_WIDTH}, (v1,i1) => { return 255; });
  });

  var x2d_label1 = Array.from({length: IMAGE_HEIGHT}, (v0,i0) => { 
    return Array.from({length: IMAGE_WIDTH}, (v1,i1) => { return (i0 == i1) ? 0 : 255; });
  });

  for (var i=0; i<IMAGE_CHANNELS; i++) {
    x3d_label0.push(x2d_label0);
    x3d_label1.push(x2d_label1);
  }
  document.getElementById("output").innerHTML += "x3d_label0.flat(Infinity).length:"+x3d_label0.flat(Infinity).length+"<br>";
  document.getElementById("output").innerHTML += "x3d_label1.flat(Infinity).length:"+x3d_label1.flat(Infinity).length+"<br>";
}


function step4() {

document.getElementById("output").innerHTML += "x3d_label0.length :"+x3d_label0.length+"<br>";
  TypedArray0 = xs3d_to_TypedArray(x3d_label0, normalArray0);
  TypedArray1 = xs3d_to_TypedArray(x3d_label1, normalArray1);
}

function step5_change_visor() {
  put_ImageArray_on_canvas(ctx0, TypedArray0);
  put_ImageArray_on_canvas(ctx1, TypedArray1);
}


// --------------------------
// Create train and test data.
// --------------------------
function step6_create_ys_data() {

  // Generate label, Shuffle.
  ys = Array.from({length: n}, (v,i) => { return (i < Math.floor(n/2)) ? 0 : 1; }).sort(() => Math.random() - 0.5);
  document.getElementById("output").innerHTML += "ys :"+ys+"<br>";
}


function step7_create_xs_data() {
  
  step3_create_unique_data();

  // Create xs.
  xs = ys.map((v,i) => { return (v == 0) ? x3d_label0 : x3d_label1; });

  document.getElementById("output").innerHTML += "shape_xs(xs) :"+shape_xs(xs)+"<br>";
}


function step8_load_test_data() {

  // Create xs_test.

  // Random selection.
  const k = Math.floor(Math.random()*n);
  xs_test = [xs.at(k)];
  ys_test = ys.at(k);

  document.getElementById("output").innerHTML += "ys_test :"+ys_test+"<br>";
  document.getElementById("output").innerHTML += "shape_xs(xs_test) :"+shape_xs(xs_test)+"<br>";
}



// --------------------------
// Model.
// --------------------------
function step9_load_model() {

  const input = tf.input({ batchShape: [batch_size, IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_CHANNELS] });
  document.getElementById("output").innerHTML += "input.shape:"+input.shape+"<br>";


  const conv0 = tf.layers.conv2d({
    inputShape: [IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_CHANNELS],
    kernelSize: 5,
    filters: 8,
    strides: 1,
    activation: 'relu',
    kernelInitializer: 'varianceScaling'
  });

  const maxpool0 = tf.layers.maxPooling2d({poolSize: [2, 2], strides: [2, 2]});
  
  const conv1 = tf.layers.conv2d({
    kernelSize: 5,
    filters: 16,
    strides: 1,
    activation: 'relu',
    kernelInitializer: 'varianceScaling'
  }));
  
  const maxpool1 = tf.layers.maxPooling2d({poolSize: [2, 2], strides: [2, 2]});

  const flatten = tf.layers.flatten();

  const dense = tf.layers.dense({
    units: NUM_OUTPUT_CLASSES,
    kernelInitializer: 'varianceScaling',
    activation: 'softmax'
  });

  const output = dense.apply(flatten.apply(maxpool1.apply(conv1.apply(maxpool0.apply(conv0.apply(input))))));

  model = tf.model({inputs: input, outputs: output});
  document.getElementById("output").innerHTML += "model: "+model+"<br>";
}


function step10_compile_model() {
  
  const optimizer = tf.train.adam();
  model.compile({
    optimizer: optimizer,
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy'],
  });

}


function step11_train_model() {

  const tf_ys = tf.tensor1d(ys, 'int32');

  const history = model.fit(tf.tensor(xs), tf.oneHot(tf_ys, 2), {
    batchSize: batch_size,
    epochs: epochs,
  });

}


function step12_predict() {

  var result = model.predict(xs_test);
  var output = result.data();
  
  document.getElementById("output").innerHTML += "output: "+output+"<br>";
}


// --------------------------
// Subfunctions
// --------------------------
function create_canvas(canvasElement_id) {

  // Create a canvas element
  var canvasElement = document.createElement('canvas');

  // Set attributes of the canvas
  canvasElement.width = width;
  canvasElement.height = height;
  canvasElement.id = canvasElement_id;
  canvasElement.class = "canvas_simple";

  document.getElementById('display_data').appendChild(canvasElement);

  var ctx = canvasElement.getContext("2d");
  
  const [r, g, b, alpha] = [Math.floor(Math.random()*255), Math.floor(Math.random()*255), Math.floor(Math.random()*255), 255];
  
  ctx.fillStyle = `rgb(${r} ${g} ${b} / ${alpha}%)`;
  
  ctx.fillRect(0, 0, width, height);

  return [ctx, canvasElement];
}


function reset(canvasElement) {
  document.getElementById('display_data').removeChild(canvasElement);
}


function convert_canvas_into_ImageData(ctx) {
  // Get canvas image
  const TypedArray = ctx.getImageData(0, 0, width, height); // Uint8ClampedArray
	
  // Convert TypedArray to normalArray
  return Array.from(TypedArray.data);
}


function xs3d_to_TypedArray(xs3d, normalArray) {
  const color_name = ['r', 'g', 'b', 'alpha'];

  // document.getElementById("output").innerHTML += "xs3d.length :"+xs3d.length+"<br>";
  //console.log("xs3d.length: ", xs3d.length);


  var r_layer = xs3d.at(0).flat(Infinity);
  var g_layer = xs3d.at(1).flat(Infinity);
  var b_layer = xs3d.at(2).flat(Infinity);

  //console.log("r_layer.length: ", r_layer.length);
  
  var c = 0;
  for (var i=0; i<normalArray.length; i+=color_name.length) {
    normalArray[i] = r_layer[c];
    normalArray[i+1] = g_layer[c];
    normalArray[i+2] = b_layer[c];
    normalArray[i+3] = 255;
    c = c + 1;
  }

  // document.getElementById("output").innerHTML += "normalArray.length :"+normalArray.length+"<br>";
  //console.log("normalArray.length: ", normalArray.length);
  return new Uint8ClampedArray(normalArray); // TypedArray
}

 
function put_ImageArray_on_canvas(ctx, TypedArray) {
  const imageData = new ImageData(TypedArray, width, height);
  ctx.putImageData(imageData, 0, 0);
}


function shape_xs(xs) {
  return [xs.length, xs.at(0).length, xs.at(0).at(0).length, xs.at(0).at(0).at(0).length];
}



</script>
</body>
</html>
