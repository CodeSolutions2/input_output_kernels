<!DOCTYPE>
<html>
<head></head>
<body>


<button id="trainModel0" onclick="trainModel0();"></button>

<progress id="progress_bar" max="100" value="0" style="display:none">0%</progress>

<div id="display_data">

<div id="output">





<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script src="https://cdn.plot.ly/plotly-2.30.0.min.js" charset="utf-8"></script>


<script>

async function trainModel0() {

  var [xs_2d, ys_1d] = await obtain_train_data();


  var xs_tf_2d = await tf.tensor(xs_2d);
  var ys_tf_1d = await tf.tensor1d(ys_1d);
  document.getElementById("output").innerHTML += xs_tf_2d;
  document.getElementById("output").innerHTML += ys_tf_1d;

  var featureNum = xs_2d.at(0).length; // columns of xs
  const outputNum = 1; // columns of ys
  
  // Define model
  var model = await regression_model(featureNum, outputNum);
  document.getElementById("output").innerHTML += "model: "+model;

  // Compile model
  await model.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ["mse"],});

  // Train model
  document.getElementById("progress_bar").style.display = "block";

  const batchSize = 1;
  const epochs = 100;
  const history = await model.fit(xs_2d, ys_1d, { 
	batchSize: batchSize, 
	epochs: epochs, 
	callbacks: { 
          onEpochEnd: async (epoch, logs) => { 
	    if (epoch % 50 == 0) {
	      document.getElementById("progress_bar").value = epoch/epochs * 100;	
	    }
	  }
        } 
  });
  
  document.getElementById("progress_bar").style.display = "none";



  await predict_data(model, ys_1d);

}


async function timeSampling_array() {

  const n = 100;
  var f = 1/10; // sampling rate.
  var t = Array.from({length:n}, (v,i) => { return i*f; });
  return t;
}


async function topic_measurements() {

  var t = await timeSampling_array();

  var sin0 = t.map((v,i) => { return Math.sin(v); });
  var sin1 = t.map((v,i) => { return 5*Math.sin(v); });
  var sin2 = t.map((v,i) => { return 10*Math.sin(v); });

  return [sin0, sin1, sin2];
}



async function obtain_train_data() {

  var [sin0, sin1, sin2] = await topic_measurements();

  // Past dataset 0
  var feature0_ds0 = sin0.map((v,i) => { return v+(0.1*Math.random()); });
  var feature1_ds0 = sin1.map((v,i) => { return v+(0.01*Math.random()); });
  var feature2_ds0 = sin2.map((v,i) => { return v+(0.1*Math.random()); });
  // var X_past0 = [feature0_ds0, feature1_ds0, feature2_ds0];

  // Past dataset 1
  var feature0_ds1 = sin0.map((v,i) => { return v+(0.01*Math.random()); });
  var feature1_ds1 = sin1.map((v,i) => { return v+(0.1*Math.random()); });
  var feature2_ds1 = sin2.map((v,i) => { return v+(0.001*Math.random()); });
  // var X_past1 = [feature0_ds1, feature1_ds1, feature2_ds1];
  
  // Way 0: stack past data
  var xs = [];
  var ys = [];
  var samples = X_current.length;
  for (var i=0; i<samples; i++) {
    
    // Randomly select features from each past dataset.
    var j = Math.floor(2*Math.random());

    var x_stack = [[feature0_ds0.at(i), feature0_ds1.at(i)], 
                   [feature1_ds0.at(i), feature1_ds1.at(i)]];
  
    xs.push(x_stack.at(j));

    var y_stack = [feature2_ds0.at(i), feature2_ds1.at(i)];
    
    ys.push(y_stack.at(j));
  }
    return [xs, ys];
}


async function obtain_test_data() {

  var [sin0, sin1, sin2] = await topic_measurements();

  // Current dataset
  var feature0_ds2 = sin0.map((v,i) => { return v+(0.001*Math.random()); });
  var feature1_ds2 = sin1.map((v,i) => { return v+(0.001*Math.random()); });
  var xs_test = [feature0_ds2, feature1_ds2];

  return xs_test;
}



function plot_data(x, y0, y1, y0_name, y1_name) {

  var title_text = "Plotting x by y";
  var x_text_trace1and2 = "x";
  var y_text_trace1and2 = "y";
  var trace1 = {x: x, y: y0, mode: "lines+markers", type: "line", name: y0_name};
  var trace2 = {x: x, y: y1, mode: "lines+markers", type: "line", name: y1_name};
  var data = [trace1, trace2];
  var layout = {grid: {rows: 1, columns: 1, pattern: "independent"}, title: title_text, xaxis: {title: x_text_trace1and2}, yaxis: {title: y_text_trace1and2}};
  Plotly.newPlot("data_display", data, layout);
}



async function regression_model(featureNum, outputNum) {

  const input = tf.input({shape: [featureNum]}); 
  const denseLayer1 = tf.layers.dense({units: 64, activation: "relu"});
  const denseLayer2 = tf.layers.dense({units: 64, activation: "relu"});
  const denseLayer3 = tf.layers.dense({units: 64, activation: "relu"});
  const denseLayer4 = tf.layers.dense({units: outputNum});  
  const output = denseLayer4.apply(denseLayer3.apply(denseLayer2.apply(denseLayer1.apply(input))));
  const model = tf.model({inputs: input, outputs: output});

  return model;
}



function predict_data(model, ys_1d) {

  var xs_test = await obtain_test_data();

  var feature2_ds2 = [];
  for (var i=0; i<xs_test.length; i++) {
    var xs_tf_test = await tf.tensor(xs_test.at(i));

    const result = await model.predict(xs_tf_test);

    // const output_value0 = await result.data();
			
    const output_value = result.dataSync();  
    document.getElementById("output").innerHTML += output_value;

    feature2_ds2.push(output_value);
  }
  
  var t = await timeSampling_array();
  await plot_data(t, feature2_ds2, ys_1d, "y_prediction", "y_actual")
}

</script>
</body>
</html>