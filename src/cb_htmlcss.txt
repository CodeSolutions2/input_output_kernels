<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="run_selection" onclick="run_selection()">Run Selection</button>

<div id="output">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>


async function run_selection() {
  var epochs = 200;
  var lr = 0.001;
  

  // Prepare data
  // var x = tf.variable(tf.scalar(0.05)); //initial value 
  const xs_tf = tf.tensor2d([[0.1, 0.3], [9.6, 9.8], [0.4, 0.7], [9.8, 9.4], [9.6, 9.3], [0.6, 0.2]]);
  const ys_tf = tf.tensor2d([[0], [1], [0], [1], [1], [0]]);
  const ds = tf.data.zip({xs_tf, ys_tf});
  // OR
  const xs = [[0.1, 0.3], [9.6, 9.8], [0.4, 0.7], [9.8, 9.4], [9.6, 9.3], [0.6, 0.2]];
  const ys = [0, 1, 0, 1, 1, 0];


  const optimizer = tf.train.adam(lr);
  // OR
  // const optimizer = tf.train.sgd(lr);


  for (var i=0; i<epochs; i++) { 
    // Way 0
    var tot_loss0 = await xs.map(xs_row,ind) => {

      return optimizer.minimize(() => {

        // Compute model prediction
        const predYs = model(tf.variable(tf.tensor(xs_row)));

        // Compute error between model prediction and y_actual (ys), this is called the loss or cost.
        var loss0 = tf.losses.softmaxCrossEntropy(tf.tensor(ys.at(ind)), predYs);
        var data_loss = loss0.data().then(data_loss => { return data_loss; });

        if (i%50 == 1) {
          document.getElementById("output").innerHTML += "predYs: "+predYs+", loss0: "+loss0+", data_loss: "+data_loss+"<br>";
        }

        return loss0;
      }, true, [loss0]);

    }); // end of for xs_row
    
    // OR

    // var variableGradients = optimizer.computeGradients(() => f(x), [x]);
    // optimizer.applyGradients(variableGradients);
    
    // OR

    // Way 1
    var tot_loss1 = await ds.forEachAsync(({xs, ys}) => {
      var loss = optimizer.minimize(() => {
        const predYs = model(xs);
        const loss = tf.losses.softmaxCrossEntropy(ys, predYs);
        loss.data().then(data_loss => if (i%20 == 1) {document.getElementById("output").innerHTML += "loss: "+data_loss+"<br>";} );
        return loss;
      });
     return loss;
    });


    // These should be arrays
    if (i%50 == 1) {
      document.getElementById("output").innerHTML += "tot_loss0: "+tot_loss0+"<br>";
      document.getElementById("output").innerHTML += "tot_loss1: "+tot_loss1+"<br>";
    }

  } // end of epochs


} // end of run_selection


function model(x) {
  
  const w1 = tf.variable(tf.randomNormal([784, 32]));
  const b1 = tf.variable(tf.randomNormal([32])); 
  const w2 = tf.variable(tf.randomNormal([32, 10])); 
  const b2 = tf.variable(tf.randomNormal([10])); 

  return x.matMul(w1).add(b1).relu().matMul(w2).add(b2);
}


</script>
</body>
</html>