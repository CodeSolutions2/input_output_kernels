<!DOCTYPE>
<html>
<head></head>
<body>

<button id="run_selection" onclick="run_selection()">Run Selection</button>

<div id="output">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>

async function run_selection() {

  const n = 200;
  const x_max = 1;
  const batch_size = 1;
  const epochs = 200;

  var x = await Array.from({length: n}, (v,i) => { return (x_max/n)* i; });
  document.getElementById("output").innerHTML += "x: "+x.slice(0,10)+"<br>";

  var xs_js = await x.map((v,i) => { return [1*Math.sin(v), 2*Math.cos(v), 5*Math.sin(v)]; });
  const rows = await xs_js.length;
  const cols = await xs_js.at(0).length;
  var xs = await tf.tensor([xs_js], [batch_size, rows, cols]);
  document.getElementById("output").innerHTML += "xs: "+xs+"<br>";

  var ys_js = await Array.from({length: n}, (v,i) => { return (i < n/2) ? 0 : 1; });
  document.getElementById("output").innerHTML += "ys_js: "+ys_js+"<br>";

  var ys0 = await tf.tensor1d(ys_js, "int32").catch(error => { document.getElementById("output").innerHTML += "error: "+error+"<br>"; });
  document.getElementById("output").innerHTML += "ys0: "+ys0+"<br>";
  
  var ys1 = await tf.oneHot(ys0, 2).catch(error => { document.getElementById("output").innerHTML += "error: "+error+"<br>"; });
  document.getElementById("output").innerHTML += "ys1: "+ys1+"<br>";

  ys = await tf.expandDims(ys1).catch(error => { document.getElementById("output").innerHTML += "error: "+error+"<br>"; });
  document.getElementById("output").innerHTML += "ys: "+ys+"<br>";

  const model = await lstm_model(batch_size, rows, cols);
  document.getElementById("output").innerHTML += "model: "+model+"<br>";

  await model.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ["mse"] })

  const history = await model.fit(xs, ys, {
    batchSize: batch_size,
    epochs: epochs,
    callbacks: {onBatchEnd} })
    .then(result => { 
      document.getElementById("output").innerHTML += "result: "+result+"<br>";
      return result.history; })
    .catch(error => { 
      document.getElementById("output").innerHTML += "error: "+error+"<br>";
    });
  document.getElementById("output").innerHTML += "history: "+history+"<br>";

  const xs_js_test = await [xs_js.at(20), xs_js.at(150)];
  const result = await model.predict(tf.tensor(xs_js_test));
  document.getElementById("output").innerHTML += "result: "+result+"<br>";

  const ys_js_test = await [ys_js.at(20), ys_js.at(150)];
  document.getElementById("output").innerHTML += "ys_js_test: "+ys_js_test+"<br>";

}



function onBatchEnd(batch, logs) {
  document.getElementById("output").innerHTML += "logs: "+logs+"<br>";
}


function onEpochEnd(epoch, logs) {
  if (epoch % 100 == 0) {
    document.getElementById("output").innerHTML += "logs: "+logs+"<br>";
  }
}





async function lstm_model(batch_size, rows, cols) {

  // Layer 0
  const input = tf.input({batchShape: [batch_size, rows, cols]});
  document.getElementById("output").innerHTML += "input.shape: "+JSON.stringify(input.shape)+"<br>";

  // Layer 1
  const lstm0 = tf.layers.lstm({
    recurrentActivation: "hardSigmoid",
    units: 32,
    returnSequences: true,
    returnState: false,
    kernelInitializer: "heNormal",
    batchSize: batch_size,
    inputShape: [rows, cols],
    activation: "tanh", 
    trainable: true, 
    dropout: 0.2
})

const input_lstm0 = lstm0.apply(input);
document.getElementById("output").innerHTML += "input_lstm0.shape: "+JSON.stringify(input_lstm0.shape)+"<br>";

// Layer 2
var attSoftmax = tf.layers.activation({activation: "softmax"});
const input_lstm0_softmax = attSoftmax.apply(input_lstm0);
document.getElementById("output").innerHTML += "input_lstm0_softmax.shape: "+JSON.stringify(input_lstm0_softmax.shape)+"<br>";

// Layer 3
const attDot_product = tf.layers.dot({axes: -1});
const input_lstm0_att = attDot_product.apply([input_lstm0_softmax, input_lstm0]);
document.getElementById("output").innerHTML += "input_lstm0_att.shape: "+JSON.stringify(input_lstm0_att.shape)+"<br>";

// Layer 4
const dense0 = tf.layers.dense({units: 1})

const output = dense0.apply(input_lstm0_att);
document.getElementById("output").innerHTML += "output.shape: "+JSON.stringify(output.shape)+"<br>";

const model = tf.model({inputs: input, outputs: output})

return model;
}


</script>
</body>
</html>