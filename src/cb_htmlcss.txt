<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="run_selection_ODE" onclick="run_selection_ODE()">run_selection_ODE</button>
<br>
<button id="run_selection_NN" onclick="run_selection_NN()">run_selection_NN</button>

<div id="output">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>


var epochs = 200;
var lr = 0.001;



async function run_selection_ODE() {
   
  // Train an ODE.
  await train_model0(lr, epochs);
}


async function run_selection_NN() {
  
  // Train a Neural Network.
  await train_model1(lr, epochs);
}


async function train_model0(lr, epochs) {

  var x = tf.variable(tf.scalar(0.05)); //initial value 
  const optimizer = tf.train.adam(lr);  //gradient descent algorithm 
  for (var i=0; i<epochs; i++) { 
    var y = optimizer.minimize(() => model0(x), true, [x]);
    
    if (i%20 == 1){ 
      document.getElementById("output").innerHTML += "y: "+y+", x: "+x+"<br>";
    }
  }

}



function model0(x) {
  const f1 = x.pow(tf.scalar(2, 'int32'))
  return f1
}






var w0;
var b0;
var w1;
var b1;
var xs;
var ys_actual;
var ys_pred;


async function train_model1(lr, epoch) {

  // [0] Define xs.
  var xs_js = [[9.2, 9, 9.4], [1.4, 1.2, 1.6], 
               [9.9, 10, 9.4], [0.5, 1.5, 1.3], 
               [9.6, 10.6, 8.5], [9.5, 10.3, 10],
               [1.5, 0.5, 1.3], [1.2, 1.9, 0.8],
               [9.6, 12.7, 10.2], [1.3, 1.7, 0.8]];
  const rows = xs_js.length;
  const cols = xs_js.at(0).length;
  xs = await tf.variable(tf.tensor(xs_js, [rows, cols]));
  document.getElementById("output").innerHTML += "xs.shape: "+xs.shape+"<br>";


  // [1] Define ys_actual.
  var ys_js = [[0], [1], 
               [0], [1], 
               [0], [0],
               [1], [1],
               [0], [1]];
  ys_actual = await tf.tensor(ys_js);


  // [2] Initialize the weights and bias.
  [w0, b0, w1, b1] = await initialize_weights(rows, cols);
  document.getElementById("output").innerHTML += "w0.shape: "+w0.shape+"<br>";
  document.getElementById("output").innerHTML += "b0.shape: "+b0.shape+"<br>";
  document.getElementById("output").innerHTML += "w1.shape: "+w1.shape+"<br>";
  document.getElementById("output").innerHTML += "b1.shape: "+b1.shape+"<br>";


  // [3] Define how one calculates the weights of the graph, or [how one descends the loss functions].
  const optimizer = tf.train.adam(lr);
  // OR
  // const optimizer = tf.train.sgd(lr); 
  

  // [4] Call train_step
  for (var i=0; i<epochs; i++) { 
    ys_pred = optimizer.minimize(() => train_step1(ys_pred), true, [ys_pred]);
    // OR
    // var loss = optimizer.minimize(() => train_step1(xs, ys_actual, w0, b0, w1, b1), true, [w0, b0, w1, b1]);

    if (i%20 == 1){ 
      // document.getElementById("output").innerHTML += "loss: "+loss+"<br>";
      document.getElementById("output").innerHTML += "<br>ys_pred: "+ys_pred+"<br>";
    }
  }

} // end of train_model1



function train_step1(ys_pred) {

  // [0] Calculate ys_pred for inputting all of xs.
  var [ys_pred, w0, b0, w1, b1] = model1(w0, b0, w1, b1);
  document.getElementById("output").innerHTML += ".";
  
  // [1] Calculate the error/loss between ys_actual and ys_pred.
  // var loss = loss_fn(ys_pred, ys_actual);
  // document.getElementById("output").innerHTML += "loss in train_step1: "+loss+"<br>";

  // return loss;
  return ys_pred;
}



// function loss_fn(ys_pred, ys_actual) {
  
//  const loss = tf.losses.sigmoidCrossEntropy(ys_actual, ys_pred);
  // loss.data().then(l => console.log('Loss', l));
//  return loss;
// }


function initialize_weights(rows, cols) {
  // The weights and biases for the two dense layers.
  var layer_dims = [rows, 2, 1];

  var w0 = tf.variable(tf.randomNormal([layer_dims.at(1), layer_dims.at(0)]));
  var b0 = tf.variable(tf.randomNormal([layer_dims.at(1), cols]));
  var w1 = tf.variable(tf.randomNormal([layer_dims.at(2), layer_dims.at(1)]));
  var b1 = tf.variable(tf.randomNormal([layer_dims.at(2), cols]));

  return [w0, b0, w1, b1];
}


function model1(w0, b0, w1, b1) {

  // Layer 0
  var Z0 = tf.matMul(w0, xs); // [ld1, ld0]*[ld0=rows, cols]
  document.getElementById("output").innerHTML += "Z0=w0*xs: "+Z0+"<br>";
  Z0 = tf.add(Z0, b0);  // [ld1, cols] + [ld1, cols]
  document.getElementById("output").innerHTML += "Z0=Z0+b0: "+Z0+"<br>";
  // [ld1, cols]

  // Calculate relu = max(0, Z0)
  // var A0 = tf.relu(Z0); // [ld1, cols]
  // OR 
  var A0 = tf.sigmoid(Z0); 
  // OR
  // var A0 = tf.softmax(Z0); 

  // Layer 1
  var y = tf.matMul(w1, A0); // [ld2, ld1]*[ld1, cols]
  document.getElementById("output").innerHTML += "y=w1*A0: "+y+"<br>";
  y = tf.add(y, b1);  // [ld2=1, cols] + [ld2=1, cols]
  document.getElementById("output").innerHTML += "y=Z1+b1: "+y+"<br>";
  // [ld2=1, cols]

  // y could be condensed to a scalar

  return [y, w0, b0, w1, b1];
}

</script>
</body>
</html>