<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="run_selection" onclick="run_selection()">Run Selection</button>

<div id="output">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script>


async function run_selection() {

  const epochs = 20;
  const batchSize = 32;
  const lr = 0.001;

  // Create xs and ys arrays.
  const rows = 100;
  const cols = 10;
  var [xs, ys] = await create_xs_ys(rows, cols);
  
  // Create a dataset, shuffle and batch 32 samples at a time.
  const bufferSize = 100;
  const ds = tf.data.zip({xs, ys}).shuffle(bufferSize).batch(batchSize);
  
  // Create the model
  const input = tf.input({shape: [cols]});
  const dense0 = tf.layers.dense({units: 32, activation: 'relu'});
  const dense1 = tf.layers.dense({units: 2, activation: 'softmax'});
  const output = dense1.apply(dense0.apply(input));
  const model = tf.model({inputs: input, outputs: output});
  document.getElementById("output").innerHTML += "model: "+model+"<br>";

  model.compile({
    optimizer: 'sgd',
    loss: 'categoricalCrossentropy',
    metrics: ['accuracy']
  });


// Train the model.
model.fitDataset(ds, {
   epochs: epochs,
   // batchSize: batchSize,
   // callbacks: {onBatchEnd}
 }).then(info => {
   document.getElementById("output").innerHTML += "info.history.acc: "+info.history.acc+"<br>";
 });


 // Predict some new samples.
 const rows_test = 2;
 const cols_test = 10;
 var [xs_test, ys_test] = await create_xs_ys(rows_test, cols_test);
 var ys_test_pred = await predict(model, xs_test);
 document.getElementById("output").innerHTML += "ys_test: "+ys_test+"<br>";
 document.getElementById("output").innerHTML += "ys_test_pred: "+ys_test_pred+"<br>";


} // end of run_selection



async function create_xs_ys(rows, cols) {

  var xs = [];
  var ys = [];
  for (var i=0; i<rows; i++) {
    if (i%2 == 0) {
      var data0 = Array.from({length: cols}, (x) => Math.random());
      xs.push(data0);
      ys.push(0);
    } else {
      var data1 = Array.from({length: cols}, (x) => 10*Math.random());
      xs.push(data1);
      ys.push(1);
    }
  }

  xs = await tf.tensor(xs, [rows, cols]);
  // xs = await tf.data.generator(xs);

  ys = await tf.oneHot(tf.tensor1d(ys, 'int32'), 2);
  // ys = await tf.data.generator(ys);

  return [xs, ys];
}



function onBatchEnd(batch, logs) {
  document.getElementById("output").innerHTML += "."+batch;
  // document.getElementById("output").innerHTML += "logs.acc: "+logs.acc+"<br>";
}



async function predict(model, xs_test) {
  return model.predict(xs_test);
}


</script>
</body>
</html>